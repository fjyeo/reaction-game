from fastapi import FastAPI, Query, HTTPException\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom logic import generate_latin_square, create_round\nfrom pydantic import BaseModel, Field\nfrom typing import List, Dict, Any\nfrom score_store import add_score, load_scores, remove_score\n\napp = FastAPI()\n\n# Allow frontend to talk to backend\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=["*"],\n    allow_methods=["*"],\n    allow_headers=["*"],\n)\n\nCOLOURS = ["red", "green", "blue"]\n\n\n@app.get("/grid")\ndef get_grid():\n    """Return a 3Ã—3 Latin-square colour grid."""\n    grid = generate_latin_square(COLOURS)\n    return {"grid": grid}\n\n\n@app.get("/round")\ndef get_round():\n    """Return a round payload with grid, target, roundId, and expiresAt."""\n    # 60 seconds is a sensible default aligned with upcoming timer work\n    return create_round(colours=COLOURS, duration_s=60)\n\n\n@app.get("/")\ndef home():\n    return {"message": "Backend is running! Go to /grid to get the colour grid."}\n\n\n# --- Scoring & Leaderboard ---\n\nclass ScoreSubmission(BaseModel):\n    name: str = Field(..., min_length=1, max_length=20)\n    score: int = Field(..., ge=0)\n\n\nclass ScoreEntry(BaseModel):\n    id: str\n    name: str\n    score: int\n    timestamp: str\n\n\n@app.post("/score", response_model=Dict[str, Any])\ndef post_score(payload: ScoreSubmission):\n    """Record a score attempt. Returns the stored entry.\n\n    Body: { name: string (1..20), score: non-negative integer }\n    """\n    name = payload.name.strip()\n    entry = add_score(name=name, score=payload.score)\n    return {"ok": True, "entry": entry}\n\n\n@app.get("/highscores", response_model=List[ScoreEntry])\ndef get_highscores(limit: int = Query(5, ge=1, le=5)):\n    """Return the top scores sorted by score desc, then timestamp asc."""\n    scores = load_scores()\n    # scores are already stored sorted desc by score; enforce and slice defensively\n    scores_sorted = sorted(scores, key=lambda e: (-int(e.get("score", 0)), e.get("timestamp", "")))\n    return [ScoreEntry(**s) for s in scores_sorted[:limit]]\n\n\n@app.delete("/score/{score_id}")\ndef delete_score(score_id: str):\n    """Delete a score by id."""\n    ok = remove_score(score_id)\n    if not ok:\n        raise HTTPException(status_code=404, detail="Score not found")\n    return {"ok": True, "id": score_id}\n\n
